# secure-programming-project
Group project for secure programming class Fall 2024 at Kent State.

# Building the project (Linux)
## Environment Vars and Initial Setup
In `sourceme.sh` update `export SEC_PROG_PATH=""` to the path of this repo.
Run `source scripts/sourceme.sh`
Run `mkdir executables`, this is where your executable files will be copied to.
Then run `buildProj`

# Summary
Build It; Break It; Fix It: Overview
In this project, you will implement a secure log to describe the state of an art gallery: the guests and
employees who have entered and left, and people that are in rooms. The log will be used by two
programs. One program, logappend, will append new information to this file, and the other, logread, 
will read from the file and display the state-of-the-artgallery according to a given query
over the log. Both programs will use an authentication token, supplied as a command-line argument, to
authenticate each other. You will build the most secure implementation you can; then you will have the opportunity to
attack other teamsâ€™ implementations, and fix bugs that other teams identify in your implementation.

# Secure Coding Practices
## CIA Triad
### Confidentiality
We use the ChaCha20 stream cipher for encryption for confidentiality of data, ensuring only those who know the key can update or read the information. Along with this, every query or update to the data is validated by the encrypted key.

### Integrity
We use an HMAC to validate that our file is not changed. It uses a salted version of the key to generate the HMAC, so that we can both authenticate the key with a hash, while ensuring the hash of that key is not valid to fake the integrity of a file.

### Availability
This application is highly available to users that have the correct key. By having rigid structure adhered to, users can ensure it stays available. This is a lesser concern on a local machine however.

## Techniques Employed
### Input Validation
All input to the application is subject to a series of regex expressions validating that they only contain potentially valid data. Next they are all stored into objects to be passed around the program, that can be trusted to have been validated.

### Output Encoding
The file format used is strictly generated by the logappend program, so any files not matching this format will be rejected.

### Parameterized Queries
There is no queries in the SQL sense but logread only accepts specific options. Along with this, these options arguments are validated.

### Error Handling and Logging
Much of the code is within try catch blocks that log less specific, yet still useful information about errors encountered.

### Memory Management
Where at all possible, we have avoid using pointers and the new operators to prevent leaks. When used we are careful to deallocate them in either destructors or calling functions. Along with this functions like strcopy are not used, and std::strings are preferred app wide.

# File Format
The format of a log file is as follows: The first 8 bytes are the nonce for the encryption. The next 32 bytes are the hash of the encryption key, to validate the key against. The final 64 bytes are reserved for the HMAC of the file. The data between the key and HMAC follows the following format exclusively.

**Note: Space sensitive**

`[timestamp] [name] [action] [room-id (optional)]`
# External Libraries
We use [libsodium](https://doc.libsodium.org/) in this project for the implementation of our HMAC, Encryption, and random nonce generation.
The specific cipher used is ChaCha20. This is a stream cipher that allows for picking up encryption and decryption operations using a counter while avoiding having to completely encrypt and reencrypt the file. The initial idea behind this approach was to leave file contents ecnrypted in memory and fetch them as needed. This ended up being outside of scope to implement this level of security however so the whole file was simply encrypted and decrypted in one go with it.